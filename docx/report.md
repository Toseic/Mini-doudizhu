### 迷你斗地主游戏AI实验报告

作者： 胡建波，孟梓墨

#### 概述

迷你斗地主是一个跟斗地主非常类似的牌类游戏，其与斗地主的区别在于将牌中的3~8去掉，剩下30张牌进行对局，其余规则完全一致。

##### 数据框架

我们的储存方法是把每个人手里的牌或者某一次打出的牌通过一个64位的`unsigned long long int`进行储存，从右向左，每四位表示一种牌从小到大储存，每四位的储存内容是某种牌的数目。

> //   <----   <----    <----  <---- <br>
> //  0001 0001 0001 0010 0011 0100 0001 0001 0011    二进制表示 <br>
> //     1    1    1    2    3    4    1    1    3   十六进制表示 <br>
> //     0x111234113   十六进制表示 <br>
> //     W    w    2    A    K    Q    J   10    9 <br>
> //   <----   <----    <----  <---- <br>

在与外界交互时或者把牌打乱时，我们可以将其解码成`vector<int>`的格式，在`vector`里面我们将牌从0开始表示9，以此类推。

>// 对应关系： <br>
>//  0  1  2  3  4  5  6    7    8 <br>
>//  9  10 J  Q  K  A  2  Joker JOKER <br>


#### 搜索框架

##### 蒙特卡洛树搜索

蒙特卡洛树搜索方法是将蒙特卡洛方法和博弈树搜索相结合的一种搜索算法，其过程为将当前的游戏状态作为一个根节点，接下来重复下面的搜索和扩展过程

<img src="E:\CodePalace\cpp code\AI-game\Mini-doudizhu\docx\img1.png" style="zoom: 33%;" />

1.扩展节点的选择:递归地应用节点选择函数，从所有待选择的节点中，选择一个节点作为本次扩展的根节点从该节点开始，对该节点表示的博弈局面进行一次模拟，在我们的迷你斗地主游戏中，我们只能知道自己打的牌，所有人已经打出去的牌，以及地主牌，剩下两位对手的牌是并不清楚的，那我们如何去构建这个根节点呢，简单的方法是将剩下两位的牌的总和（这是可以由已知信息推断出的），随机分配个两人，在后面我们会介绍我们所使用的优化方法，也就是猜牌算法优化
2.扩展步骤:将一个或多个节点增加到MCTS搜索树中. 普通的策略是每次迭代只向博弈树中增加一个新节点，在这个游戏中所体现出的是将当前出牌的玩家所能出的牌（需要压上家的牌或者可以随意出）全部取出来，将他们打出去，把打出去后的节点扩展为新的状态，在后面会介绍如何通过拆牌算法的优化对搜索树的宽度进行限制，进而提高搜索效率。
3.模拟:模拟实际玩家博弈过程，进行从博弈树的叶子节点到终止状态的一次博弈过程，简单而言就是让三人随机出牌，然后观察胜率分布，我们也对这一部分进行了一些优化，在后文会介绍。
4.反馈:模拟的结果会从博弈树的叶子节点开始，通过逐层反馈给父节点的方式，最终将模拟结果返回给根节点。



#### 算法优化

##### 拆牌算法优化

在我们的拓展结点的过程中，对宽度的限制非常重要，如果我们不加以剪枝，搜索树会向一些很差的节点进行搜索，这会很大的影响搜索的深度和效率，我们剪枝的方法就是通过一个人工的评估算法将所有可行的出牌方式中将有价值的出牌方式选取出来，然后对他们进行扩展。

首先我们可以考虑单牌，我们的手牌中所有的牌都能够当单牌打出去，但是哪些是适合打出的呢，我们人类经验应该是这样子的：

1.将所有没办法跟别的牌组合的牌拿出，也就是只能单打的牌，放入一个待选的列表中

2.再将拿出之后不影响其他组合的牌拿出，比如9,9,10,J,Q,K,A，在这里如果我们如果把一个9拿出，不会影响到9~A的这个顺子，所以说9可以被拿出来作为单牌打出去。将这些牌也放入列表。

3.在列表里面取出最小的当单牌（或者三带一或四带二）打出去。

我们在拆牌的算法中也用类似的思路选出最适合拿来单打的单牌和对子，具体方法就是统计每种牌在所有可出的牌的组合中出现的次数，如果发现某一种牌仅仅出现过一次，那么我们可以将其放入单打出的候选列表中，那么如何找出在拿出之后不影响其他组合的牌呢，我们可以在找到一些较大的牌（主要是顺子）时，将这些牌先移除，然后考虑剩下的牌，把其中不会影响到别的组合的牌取出。

接下来考虑顺子，在迷你斗地主中单张牌的顺子只有三种，即9~K， 10~A， 9~A这三种，那打出哪种合适呢？这需要具体根据情况而讨论，人工评估并不能准确的判断，这个部分可以交给mcts解决。

关于炸弹的处理，在我们这个AI中，我们对炸弹的处理是一定不会拆开打，所以我们可以不考虑炸弹在别的方面的影响。

剩下的牌基本上就包括三张，一些张数较多的牌，我们都认为这些牌是有搜索价值的，所以我们把他们全部放入待拓展的储存列表中。

##### 猜牌算法优化

玩过斗地主的人都或多或少地能感受到猜牌这一行为的重要性，而对于使用MCTS算法的bot，猜牌意味着减少横向搜索空间。

在人与人的对局中，我们常常通过观察对方得意的表情而猜测:

> "他手上一定有好牌"--->对方炸弹，火箭等概率增大

或是队友的语言:

> "给阿姨倒一杯卡布奇诺"--->队友手中的牌很好，需要我压制住地主

而bot之间并没有语言，表情等交流，于是只能根据对方的出牌历史进行推测。

这里我们采用了一个非常简单的原则：、

> X∈9~K && 我方(user0)无X & &场上只有一方(user1)出过X && 还有X未被打出 => 另外一方(user2)大概率有多于一张X
> 
> (拆炸弹行为发生的概率很低）

如果满足以上条件，则以一定概率把一张X分给user2（实现方法为rand_int(10)<P)。

接下来考虑地主（如果我方为地主自动跳过），如果地主牌未被打出，则将剩余牌中的牌分给地主。

然后使用random_shuffle函数将剩余牌随机排序，并按照双方剩余牌的数目分给两方。

经过测试，猜牌算法的效果很好，减少了许多不合理的出牌方法。

##### 随机对局优化

关于随机对局，我们在进行调试时发现纯随机出牌的的对局会这个问题：

> 在出牌时打单牌的概率偏高，这是因为手牌中所有的牌都能当单牌打出，导致在候选的操作中，单牌占比偏高，如果都打单牌的话会影响对局的质量。

所以可以对随机对局进行一些优化：由于随机对局的算法如果写的偏复杂，会影响速度，所以说我们简单的进行一个剪枝就可以了，我们可以设置一个界限，如果我们发现当前出牌的方案的个数超过了这个界限，就随即删掉一半的单牌，这样可以减少出单牌的可能性。

##### 参数优化

#### 不足之处

由于时间仓促，猜牌算法并不完善，包括概率设置，以及对历史出牌的信息更深入的挖掘等等方面仍然需要进一步优化。

##### 搜索

##### 随机对局



