### 迷你斗地主游戏AI实验报告

报告人： 胡建波，孟梓墨

#### 概述

迷你斗地主是一个跟斗地主非常类似的牌类游戏，其与斗地主的区别在于将牌中的3~8去掉，剩下30张牌进行对局，其余规则完全一致。

##### 数据框架

我们的储存方法是把每个人手里的牌或者某一次打出的牌通过一个64位的`unsigned long long int`进行储存，从右向左，每四位表示一种牌从小到大储存，每四位的储存内容是某种牌的数目。

> <----   <----    <----  <---- <br>
> 0001 0001 0001 0010 0011 0100 0001 0001 0011    二进制表示 <br>
>    1       1        1       2        3        4       1        1       3   十六进制表示 <br>
> 0x111234113   十六进制表示 <br>
> W     w         2      A        K       Q        J       10      9 <br>
> <----   <----    <----  <---- <br>

在与外界交互时或者把牌打乱时，我们可以将其解码成`vector<int>`的格式，在`vector`里面我们将牌从0开始表示9，以此类推。

>对应关系： <br>
>0   1    2   3   4   5   6     7        8 <br>
>9  10   J   Q   K   A   2  Joker JOKER <br>


#### 搜索框架

##### 蒙特卡洛树搜索

蒙特卡洛树搜索方法是将蒙特卡洛方法和博弈树搜索相结合的一种搜索算法，其过程为将当前的游戏状态作为一个根节点，接下来重复下面的搜索和扩展过程。

<img src="https://cdn.jsdelivr.net/gh/Cod1ngcat/gihubio_img@master/mcts.7c022aelgqo0.webp" style="zoom: 33%;" />

1.扩展节点的选择:递归地应用节点选择函数，从所有待选择的节点中，选择一个节点作为本次扩展的根节点从该节点开始，对该节点表示的博弈局面进行一次模拟，在我们的迷你斗地主游戏中，我们只能知道自己打的牌，所有人已经打出去的牌，以及地主牌，剩下两位对手的牌是并不清楚的，那我们如何去构建这个根节点呢，简单的方法是将剩下两位的牌的总和（这是可以由已知信息推断出的），随机分配个两人，在后面我们会介绍我们所使用的优化方法，也就是猜牌算法优化。

2.扩展步骤:将一个或多个节点增加到MCTS搜索树中. 普通的策略是每次迭代只向博弈树中增加一个新节点，在这个游戏中所体现出的是将当前出牌的玩家所能出的牌（需要压上家的牌或者可以随意出）全部取出来，将他们打出去，把打出去后的节点扩展为新的状态，在后面会介绍如何通过拆牌算法的优化对搜索树的宽度进行限制，进而提高搜索效率。

3.模拟:模拟实际玩家博弈过程，进行从博弈树的叶子节点到终止状态的一次博弈过程，简单而言就是让三人随机出牌，然后观察胜率分布，我们也对这一部分进行了一些优化，在后文会介绍。

4.反馈:模拟的结果会从博弈树的叶子节点开始，通过逐层反馈给父节点的方式，最终将模拟结果返回给根节点。



#### 算法优化

##### 拆牌算法优化

在拓展结点的过程中，对宽度的限制非常重要，如果我们不加以剪枝，搜索树会向一些很差的节点进行搜索，这会很大的影响搜索的深度和效率，我们剪枝的方法就是通过一个人工的评估算法将所有可行的出牌方式中将有价值的出牌方式选取出来，然后对他们进行扩展。

首先可以考虑单牌，我们的手牌中所有的牌都能够当单牌打出去，但是哪些是适合打出的呢，人类经验应该是这样子的：

1.将所有没办法跟别的牌组合的牌拿出，也就是只能单打的牌，放入一个待选的列表中。

2.再将拿出之后不影响其他组合的牌拿出，比如9,9,10,J,Q,K,A，在这里如果我们如果把一个9拿出，不会影响到9~A的这个顺子，所以说9可以被拿出来作为单牌打出去。将这些牌也放入列表。

3.在列表里面取出最小的当单牌（或者三带一或四带二）打出去。

我们在拆牌的算法中也用类似的思路选出最适合拿来单打的单牌和对子，具体方法就是统计每种牌在所有可出的牌的组合中出现的次数，如果发现某一种牌仅仅出现过一次，那么可以将其放入单打出的候选列表中，那么如何找出在拿出之后不影响其他组合的牌呢，可以在找到一些较大的出牌方案（主要是顺子）后，将这些牌移除，然后考虑剩下的牌，把其中不会影响到别的组合的牌取出。

接下来考虑顺子，在迷你斗地主中单张牌的顺子只有三种，即9~K， 10~A， 9~A这三种，那打出哪种合适呢？这需要具体根据情况而讨论，人工评估并不能准确的判断，这个部分可以交给mcts解决。

关于炸弹的处理，在我们的这个AI中，对炸弹的处理是一定不会拆开打，所以可以不考虑炸弹在别的方面的影响。

剩下的牌基本上就包括三张，一些张数较多的牌，我们都认为这些牌是有搜索价值的，所以我们把他们全部放入待拓展的储存列表中。

##### 猜牌算法优化

玩过斗地主的人都或多或少地能感受到猜牌这一行为的重要性，而对于使用MCTS算法的bot，猜牌意味着能够提高随机rollout结果的质量。

在人与人的对局中，我们常常通过观察对方得意的表情而猜测:

> "他手上一定有好牌"--->对方炸弹，火箭等概率增大.

或是队友的语言:

> "给阿姨倒一杯卡布奇诺"--->队友手中的牌很好，需要我压制住地主。

而bot之间并没有语言，表情等交流，于是只能根据对方的出牌历史进行推测。

这里我们采用了一些原则加以判断，


判断原则主要包括两个部分：

第一个是根据地主牌判断（这个判断只有当我方是农民时才会使用），地主的原始手牌中有三张地主牌是已知的，如果地主没有打出过这三张牌中的某一部分，我们可以认为他的手里是一定有这部分牌。

第二个判断依据是假设对方不会拆开炸弹，

```cpp
M∈9~K && 对方两人的起始牌加在一起有4张M && 场上只有一方(user1)出过M && 还有M未被打出 => 另外一方(user2)大概率有多于一张M
```

如果对方两个人的其中一人打出过M，我们可以认为他并不会把自己的炸弹拆开了打，所以可以把剩下的M分配给另一个对手（实现方法为(`rand_int(K)/K) < P`，P为设定的一个概率)。

然后使用random_shuffle函数将剩余牌随机排序，并按照双方剩余牌的数目分给两方。

经过测试，猜牌算法的能部分提高AI的出牌质量。

##### 随机对局优化

关于随机对局，我们在进行调试时发现纯随机出牌的的对局会这个问题：

> 在出牌时打单牌的概率偏高，这是因为手牌中所有的牌都能当单牌打出，导致在候选的操作中，单牌占比偏高，如果都打单牌的话会影响对局的质量。

所以可以对随机对局进行一些优化：由于随机对局的算法如果写的偏复杂，会影响速度，所以说我们简单的进行一个剪枝就可以了，我们可以设置一个界限，如果我们发现当前出牌的方案的个数超过了这个界限，就随即删掉一半的单牌，这样可以减少出单牌的可能性。









#### 不足之处

##### 搜索

由于搜索时间的限制以及数据结构的设置不够完全合理，搜索的效率并不能让我们十分满意，部分原因在于游戏状态并不完全已知，随机分发的或者猜测出的手牌的内容的不准确会很大的影响随机对局的结果，尽管使用了猜牌算法加以优化，仍然不能有效地改变这一现状，个人认为改进的方案有：

1. 提高猜牌算法水平（由于时间仓促，猜牌算法并不完善，包括概率设置，以及对历史出牌的信息更深入的挖掘等等方面仍然需要进一步优化。），一个简单的设想是把猜出来的对手的牌跟原本打出的牌加在一起，然后考虑在这样的原始状态下，对手的出牌是否是合理的，如果合理性较高，我们可以认为猜出的牌是较为准确的。（不过这种方法可能会被随机出牌的算法坑死）。
2. 可以在搜索树中增加对手的不同状态的节点，我们现在的算法是在一次猜完对手的牌后，就认定对手是这个状态然后接着搜索，所以说如果在原来的猜测就是跟对手真实的手牌差之甚远（这也跟猜牌算法的水平有关），那么接下来的搜索就失去了价值，改进方案可以是增加猜牌次数，将几次猜牌的结果都作为根节点，构建多个搜索树，由于每个搜索树的根节点的己方的手牌是相同的，所以待出牌的方案个数是一致的，我们可以对比每个方案在各个搜索树中的结果，如果某个方案在大部分的搜索树的结果中都有良好的结果，那么可以认为这是一个好的出牌方案。但是这个解决方案可能会影响搜索范围和深度，这个方案目前也只是处于思考的阶段，尚未投诸实践。

##### 随机对局

在随机对局时，虽然使用了前面所说的单牌减半的剪枝来提高随机对局质量，但是随机对局的质量还是有提高的空间，个人认为可以尝试将随机出牌改成类似于贪心算法的出牌方式，在这一次出牌张数最多和最快把牌打完之间选择折中的出牌方案，这样可能可以提高随机对局的质量。

